<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="A finite volume tool in Matlab and Julia">
<meta name="viewport" content="width=device-width">
<title>FVTool (old posts, page 1) | FVTool</title>
<link href="assets/css/all.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://fvt.simulkade.com/index-1.html">
<link rel="prev" href="index-2.html" type="text/html">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'center' to center equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
            styles, `#sidebar-checkbox` for behavior. -->
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"><!-- Toggleable sidebar --><div class="sidebar" id="sidebar">
        <div class="sidebar-item">
            <p>Theme by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> and <a href="https://twitter.com/ralsina" target="_blank">@ralsina</a></p>
        </div>
        
    <nav id="menu" role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="http://www.simulkade.com/stories/about.html">About</a>
        <a class="sidebar-nav-item" href="http://www.simulkade.com">Simulkade</a>
        <a class="sidebar-nav-item" href="archive.html">Archive</a>
        <a class="sidebar-nav-item" href="categories/index.html">Tags</a>
        <a class="sidebar-nav-item" href="rss.xml">RSS feed</a>
    
    
    </nav>
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          
    <h3 id="brand" class="masthead-title">
      <a href="http://fvt.simulkade.com/" title="FVTool" rel="home">FVTool</a>
    </h3>

        </div>
      </div>

      <div class="container content" id="content">
        

<div class="posts">
    <article class="post h-entry post-text"><header><h1 class="post-title p-name"><a href="posts/2014-10-26-transient-diffusion-fvm.html" class="u-url">2D transient diffusion equation; numerical FVM solution</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Ali A. Eftekhari</span></p>
            <p class="dateline"><a href="posts/2014-10-26-transient-diffusion-fvm.html" rel="bookmark"><time class="post-date published dt-published" datetime="2014-10-26T22:35:13+01:00" title="2014-10-26 22:35">2014-10-26 22:35</time></a></p>
                <p class="commentline">
        
    <a href="posts/2014-10-26-transient-diffusion-fvm.html#disqus_thread" data-disqus-identifier="cache/posts/2014-10-26-transient-diffusion-fvm.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><strong>Important Update</strong>: the codes in this post will not work with the new version of FVTool. Download the old version of FVTool <a href="https://github.com/simulkade/FVTool/archive/v0.11.zip">here</a>.</p>
<h3>A time dependent diffusion problem</h3>
<p>In my last post, I promised to solve a time dependent conduction problem. Indeed I tried to keep my promise by writing a full post about single phase compressible flow in porous media. But in the middle of writing, I noticed that there are too many things that need to be clarified before we can jump into that problem. Therefore, I decided to hold my horses and only solve a simple time-dependent diffusion problem. I this post, you are going to learn how to define the initial conditions and use a <code>for</code> loop for time steps.</p>
<h3>This blog's icon</h3>
<p>If you look carefully at this open tab in your browser, you see a colorful icon that looks like a bad design for a gay flag. It is nothing but a square domain, which has been initially at a concentration c=1.0, and suddenly its boundaries are exposed to an environment at a zero concentration, c=0.0 and mass starts moving out of the domain only by diffusion mechanism. As simple as that!</p>
<h3>We gaan beginnen</h3>
<p>The equation for this problem reads </p>
<p>$$\frac{\partial c}{\partial t} +\nabla.(-D \nabla c) = 0$$ </p>
<p>where <em>D</em> [m^2/s] is the diffusion coefficient and <em>c</em> [mol/m^3] is the concentration. The boundary conditions are all Dirichlet, i.e.,</p>
<p>$$ c=0 $$</p>
<p>The coding steps are as always in the following sequence:</p>
<ol>
<li>Geometry and mesh</li>
<li>Boundary condition</li>
<li>Initial condition</li>
<li>Matrix of coefficients</li>
<li>Linear solver</li>
</ol>
<p>The geometry can be defined as</p>
<pre class="code literal-block"><span></span><span class="n">clc</span><span class="p">;</span> <span class="n">clear</span><span class="p">;</span> <span class="n">close</span> <span class="n">all</span><span class="p">;</span>
<span class="n">L</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c">% [m] length of the domain</span>
<span class="n">H</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c">% [m] height of the domain</span>
<span class="n">Nx</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c">% number of grids in x direction</span>
<span class="n">Ny</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c">% number of grids in y direction</span>
<span class="n">m</span> <span class="p">=</span> <span class="n">createMesh2D</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">);</span> <span class="c">% create the mesh</span>
</pre>


<p>Then the boundary conditions are defined. Just as a reminder, the boundaries are defined by the following general relation:</p>
<p>$$ a \nabla \phi.\mathbf{n}+b \phi = c$$</p>
<p>The code for specifying the boundary condition and finding the matrix of coefficients for the boundary nodes is written as</p>
<pre class="code literal-block"><span></span><span class="n">bc</span> <span class="p">=</span> <span class="n">createBC</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="n">bc</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bc</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bc</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bc</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">[</span><span class="n">M_bc</span><span class="p">,</span> <span class="n">RHS_bc</span><span class="p">]</span> <span class="p">=</span> <span class="n">boundaryCondition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
</pre>


<p>Now is time to learn something new: defining initial conditions. We remember that the variables are build over the domain using the <code>createCellVariable</code> function. We used it before to assign a conductivity value to each cell in the domain. We don't need to assign transfer coefficients to the ghost cells. Now, if we need to define a cell variable which also has value on the ghost cell. The value on the ghost cells should be consistent with the boundary condition. Therefore, we send the boundary condition as an extra input the the <code>createCellVariable</code> function. The function will take care of the rest!
One more thing. The initial condition must be assigned to a structure that is called <code>Old</code>. In fact, the <code>transitionTerm</code> that returns the matrix of coefficients for the transient term needs the initial conditon to be written this way.</p>
<pre class="code literal-block"><span></span><span class="n">D_val</span> <span class="p">=</span> <span class="mf">1e-5</span><span class="p">;</span> <span class="c">% [m^2/s] diffusion coefficient</span>
<span class="n">D</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D_val</span><span class="p">);</span> <span class="c">% assign diff. coef. to each cell</span>
<span class="n">D_face</span> <span class="p">=</span> <span class="n">geometricMean</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D</span><span class="p">);</span> <span class="c">% average of diff. coef. on cell faces</span>
<span class="n">M_diff</span> <span class="p">=</span> <span class="n">diffusionTerm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D_face</span><span class="p">);</span>
<span class="n">c_init</span> <span class="p">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c">% [mol/m^3] initial concentration</span>
<span class="n">c</span><span class="p">.</span><span class="n">Old</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c_init</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span> <span class="c">% initial condition</span>
<span class="n">alfa</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c">% it will be required later</span>
</pre>


<p>The next step is to define the time steps and the final time of the simulation. Normally, for a diffusion problem, we can choose a time step based on the length of the domain and the diffusion coefficient, i.e., a fraction of $L^2/D$. In Matlab, we can write</p>
<pre class="code literal-block"><span></span><span class="n">t_end</span> <span class="p">=</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">L</span>^<span class="mi">2</span><span class="o">/</span><span class="n">D_val</span><span class="p">;</span> <span class="c">% [s] final time</span>
<span class="n">dt</span> <span class="p">=</span> <span class="n">t_end</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span> <span class="c">% [s] time step </span>
</pre>


<p>And the final part. We have to solve the PDE literally step by step, in a loop. We start from the initial condition (t=0) and find the concentration profile for t=dt. Then we use the new concentration profile as the initial condition and solve the PDE for the next time step and so on. The Matlab code for this procedure reads</p>
<pre class="code literal-block"><span></span><span class="k">for</span> <span class="n">t</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="n">dt</span><span class="p">:</span><span class="n">t_end</span>
        <span class="c">% This part must be inside the time loop:</span>
    <span class="p">[</span><span class="n">M_trans</span><span class="p">,</span> <span class="n">RHS_trans</span><span class="p">]</span> <span class="p">=</span> <span class="n">transientTerm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">alfa</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">c_new</span> <span class="p">=</span> <span class="n">solvePDE</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M_bc</span><span class="o">+</span><span class="n">M_trans</span><span class="o">-</span><span class="n">M_diff</span><span class="p">,</span> <span class="n">RHS_trans</span><span class="o">+</span><span class="n">RHS_bc</span><span class="p">);</span>
    <span class="n">c</span><span class="p">.</span><span class="n">Old</span> <span class="p">=</span> <span class="n">c_new</span><span class="p">;</span> <span class="c">% replace the old value with the new time step</span>
    <span class="n">visualizeCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c_new</span><span class="p">);</span> <span class="n">title</span><span class="p">([</span><span class="s">'t= '</span> <span class="n">num2str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="s">' s'</span><span class="p">]);</span>
        <span class="n">drawnow</span><span class="p">;</span>
<span class="k">end</span>
</pre>


<p>The code will show you how the material escapes the square domain through the boundaries. We can do a bit of mass balance test on the whole thing, which I will explain later.<br>
This is the code in one piece:</p>
<pre class="code literal-block"><span></span><span class="n">clc</span><span class="p">;</span> <span class="n">clear</span><span class="p">;</span> <span class="n">close</span> <span class="n">all</span><span class="p">;</span>
<span class="n">L</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c">% [m] length of the domain</span>
<span class="n">H</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c">% [m] height of the domain</span>
<span class="n">Nx</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c">% number of grids in x direction</span>
<span class="n">Ny</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c">% number of grids in y direction</span>
<span class="n">m</span> <span class="p">=</span> <span class="n">createMesh2D</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">);</span> <span class="c">% create the mesh</span>
<span class="n">bc</span> <span class="p">=</span> <span class="n">createBC</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="n">bc</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bc</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bc</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">bc</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">bc</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">[</span><span class="n">M_bc</span><span class="p">,</span> <span class="n">RHS_bc</span><span class="p">]</span> <span class="p">=</span> <span class="n">boundaryCondition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span>
<span class="n">D_val</span> <span class="p">=</span> <span class="mf">1e-5</span><span class="p">;</span> <span class="c">% [m^2/s] diffusion coefficient</span>
<span class="n">D</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D_val</span><span class="p">);</span> <span class="c">% assign diff. coef. to each cell</span>
<span class="n">D_face</span> <span class="p">=</span> <span class="n">geometricMean</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D</span><span class="p">);</span> <span class="c">% average of diff. coef. on cell faces</span>
<span class="n">M_diff</span> <span class="p">=</span> <span class="n">diffusionTerm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D_face</span><span class="p">);</span>
<span class="n">c_init</span> <span class="p">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c">% [mol/m^3] initial concentration</span>
<span class="n">c</span><span class="p">.</span><span class="n">Old</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c_init</span><span class="p">,</span> <span class="n">bc</span><span class="p">);</span> <span class="c">% initial condition</span>
<span class="n">alfa</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c">% it will be required later</span>
<span class="n">t_end</span> <span class="p">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">L</span>^<span class="mi">2</span><span class="o">/</span><span class="n">D_val</span><span class="p">;</span> <span class="c">% [s] final time</span>
<span class="n">dt</span> <span class="p">=</span> <span class="n">t_end</span><span class="o">/</span><span class="mi">100</span><span class="p">;</span> <span class="c">% [s] time step </span>
<span class="k">for</span> <span class="n">t</span> <span class="p">=</span> <span class="mi">0</span><span class="p">:</span><span class="n">dt</span><span class="p">:</span><span class="n">t_end</span>
    <span class="p">[</span><span class="n">M_trans</span><span class="p">,</span> <span class="n">RHS_trans</span><span class="p">]</span> <span class="p">=</span> <span class="n">transientTerm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">alfa</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">c_new</span> <span class="p">=</span> <span class="n">solvePDE</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M_bc</span><span class="o">+</span><span class="n">M_trans</span><span class="o">-</span><span class="n">M_diff</span><span class="p">,</span> <span class="n">RHS_trans</span><span class="o">+</span><span class="n">RHS_bc</span><span class="p">);</span>
    <span class="n">c</span><span class="p">.</span><span class="n">Old</span> <span class="p">=</span> <span class="n">c_new</span><span class="p">;</span>
    <span class="n">visualizeCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c_new</span><span class="p">);</span> <span class="n">title</span><span class="p">([</span><span class="s">'t= '</span> <span class="n">num2str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="s">' s'</span><span class="p">]);</span>
        <span class="n">drawnow</span><span class="p">;</span>
<span class="k">end</span>
</pre>


<p>One of the frames in your final result should look like this:
<img alt="2d diffusion fvm" src="trans_diff.png"></p>
</div>
    </div>
    </article><article class="post h-entry post-text"><header><h1 class="post-title p-name"><a href="posts/2014-06-25-conduction-diffusion-explained.html" class="u-url">Conduction and diffusion: a brief tutorial</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Ali A. Eftekhari</span></p>
            <p class="dateline"><a href="posts/2014-06-25-conduction-diffusion-explained.html" rel="bookmark"><time class="post-date published dt-published" datetime="2014-06-25T22:35:13+01:00" title="2014-06-25 22:35">2014-06-25 22:35</time></a></p>
                <p class="commentline">
        
    <a href="posts/2014-06-25-conduction-diffusion-explained.html#disqus_thread" data-disqus-identifier="cache/posts/2014-06-25-conduction-diffusion-explained.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><strong>Important Update</strong>: the codes in this post will not work with the new version of FVTool. Download the old version of FVTool <a href="https://github.com/simulkade/FVTool/archive/v0.11.zip">here</a>.</p>
<h3>Warning</h3>
<p>This post is not edited. You may find horrible English mistakes.</p>
<h3>Diffusion/conduction equation; mass and heat transfer</h3>
<p>As a chemical engineer mass transfer is my favorite topic, which is sort of strange given the fact that heat transfer is way easier to feel and understand. It has to be due to the very busy schedule of my heat transfer Professor, who was involved in a project at the time and did not spend enough time on getting ready for his teaching duties, unlike my mass transfer Professor. Back to business...  </p>
<p>Temperature gradient is the driving force behind the conductive heat transfer, and the gradient of chemical potential is the driving force behind the diffusive mass transfer. At low concentrations, the gradient of the chemical potential can be replaced by the concentration gradient. Here I'm going to show you how to solve a conservation equation when the only flux term is the diffusive heat or conductive mass (doesn't sound as funny as I expected). The equation reads</p>
<p>$$ \nabla . (-\lambda \nabla \phi)=q, $$</p>
<p>where for mass transfer, $\lambda$ denotes the diffusivity (m^2/s) and $\phi$ denotes the concentration (mol/m^3), and <em>q</em> is a mass source term (mol/(m^3.s)) and for heat transfer, $\lambda$ denotes the conductivity (J/(m.K.s)) and $\phi$ denotes the temperature (K), and <em>q</em> is a heat source term (J/(m^3.s)). There are other physical phenomena that can be described by the above relation, e.g., <a href="http://en.wikipedia.org/wiki/Poisson%27s_equation">Poisson equation</a> or <a href="http://en.wikipedia.org/wiki/Darcy%27s_law">flow in porous media</a>, in which $\lambda$ denotes the total mobility (permeability divided by the viscosity for single phase flow), and $\phi$ denotes pressure.</p>
<h3>Boundary conditions</h3>
<p>I think Dirichlet (constant value) and Neumann (constant flux) boundary conditions are quite clear in terms of their physical meaning. However, there are two important situations that lead to a Robin boundary condition. In heat transfer, when a boundary is gaining/losing heat to a medium with a constant temperature of $$ T_{\infty} $$ by convection mechanism with a heat transfer coefficient <em>h</em> (J/(m^2.K.s)), the energy balance equation at the boundary reads</p>
<p>$$ -\lambda (\mathbf{n}.\nabla T) = h(T-T_{\infty}), $$</p>
<p>which can be rearranged to the following form that can be formulated in the FVMtool:</p>
<p>$$\frac{\lambda}{h} (\mathbf{n}.\nabla T) + T = T_{\infty}$$</p>
<p>For the mass transfer, if mass is produced or consumed at a boundary by a first order reaction rate, the equation reads</p>
<p>$$ -\lambda (\mathbf{n}.\nabla c) = k_0 c, $$</p>
<p>where $k_0$ is the rate constant of the reaction that happens on the boundary.
For a chapter of my thesis, I encountered this sort of boundaries and it was the main reason that I rewrote the implementation of boundary condition from scratch. I will talk about the implementation of the boundary conditions later in a separate post.</p>
<h3>A (sort of) real problem</h3>
<p><a href="http://en.wikipedia.org/wiki/Fin_%28extended_surface%29">Fins</a> are used to increase the heat transfer area and thus the rate of heat transfer. Here we are going to model a fin in 2D. The base of the rectangular fin is attached to a surface with a constant temperature of 100 degree Celsius. The fin is made of <a href="http://en.wikipedia.org/wiki/Aluminium">Aluminum</a>, with a <a href="http://en.wikipedia.org/wiki/List_of_thermal_conductivities">thermal conductivity</a> of 237 W/(m.K), with a thickness of 0.1 cm and a length of 10 cm. The fin is exposed to a air at a constant temperature of 25 degree Celsius, and the heat transfer coefficient is 10 W/(m^2.K). This number may be off so you can estimate it using one of <a href="http://en.wikipedia.org/wiki/Heat_transfer_coefficient">these correlations</a>.<br>
Let us jump into our Matlab <a href="https://github.com/simulkade/FVTool">FVTool</a>, and solve this problem numerically using the finite volume method.</p>
<h3>Solution procedure</h3>
<p>First, we start by defining the domain and creating the mesh structure:</p>
<pre class="code literal-block"><span></span><span class="n">clc</span><span class="p">;</span> <span class="n">clear</span><span class="p">;</span> <span class="c">% clean the command prompt, clean the memory</span>
<span class="n">L</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span> <span class="c">% 10 cm length</span>
<span class="n">W</span> <span class="p">=</span> <span class="mf">0.01</span><span class="p">;</span> <span class="c">% 1 cm thickness</span>
<span class="n">Nx</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span> <span class="c">% number of cell in x direction</span>
<span class="n">Ny</span> <span class="p">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c">% number of cells in the y direction</span>
<span class="n">m</span> <span class="p">=</span> <span class="n">createMesh2D</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">W</span><span class="p">);</span> <span class="c">% creates a 2D Cartesian grid</span>
</pre>


<p>Now, we define the the transfer coefficients. We assume that the thermal conductivity is constant on the whole domain. However, we need to assign this constant value to each individual cell. This is done by the function <code>createCellVariable</code>. After creating this thermal conductivity field, we have to calculate the average values on the interface between cells or the <em>faces</em>. Again, in this special case, the average values are equal to a constant. But in other cases when the conductivity varies with space, the averaging becomes more important. Three averaging techniques are available in the <code>FVTool</code>, viz. <em>arithmetic</em>, <em>geometric</em>, and <em>harmonic</em>. The output of these averaging functions is always a face variable. Let's see that in action: </p>
<pre class="code literal-block"><span></span><span class="n">T_inf</span> <span class="p">=</span> <span class="mi">25</span><span class="o">+</span><span class="mf">273.15</span><span class="p">;</span> <span class="c">% [K] ambient temperature</span>
<span class="n">T_base</span> <span class="p">=</span> <span class="mi">100</span><span class="o">+</span><span class="mf">273.15</span><span class="p">;</span> <span class="c">% [K] temperature at the base of the fin</span>
<span class="n">k_val</span> <span class="p">=</span> <span class="mi">237</span><span class="p">;</span> <span class="c">% W/(m.K) thermal conductivity</span>
<span class="n">h_val</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c">% W/(m^2.K) heat transfer coefficient</span>
<span class="n">k</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k_val</span><span class="p">);</span> <span class="c">% assign thermal cond. value to all cells</span>
<span class="n">k_face</span> <span class="p">=</span> <span class="n">geometricMean</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="c">% geometric average of the thermal conductivity values on the cell faces</span>
</pre>


<p>Now, we can define the boundary conditions. Here, we have one Dirichlet (constant temperature) and three Robin boundaries. The general boundary condition is defined as </p>
<p>$$ a (\mathbf{n}.\nabla \phi)+b\phi = c. $$</p>
<p><em>a</em>, <em>b</em>, and <em>c</em> must be defined in the program. Here, we have $a=\lambda/h$, $b=1$, and $c=T_{\infty}$. Don't forget to include the sign of the normal vector for the bottom boundary. The normal vector is in the opposite direction of the y axis and therefore its sign must be included in the temperature gradient term. I will talk about it in more details later.</p>
<pre class="code literal-block"><span></span><span class="n">BC</span> <span class="p">=</span> <span class="n">createBC</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c">% creates a BC structure for the domain m; all Neumann boundaries</span>
<span class="n">BC</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="n">T_base</span><span class="p">;</span> <span class="c">% convert the left boundary to constant temperature</span>
<span class="n">BC</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="n">k_val</span><span class="o">/</span><span class="n">h_val</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="n">T_inf</span><span class="p">;</span> <span class="c">% right boundary to Robin</span>
<span class="n">BC</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="n">k_val</span><span class="o">/</span><span class="n">h_val</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">top</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="n">T_inf</span><span class="p">;</span> <span class="c">% top boundary to Robin</span>
<span class="n">BC</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">a</span><span class="p">(:)=</span><span class="o">-</span><span class="n">k_val</span><span class="o">/</span><span class="n">h_val</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">bottom</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="n">T_inf</span><span class="p">;</span> <span class="c">% bottom boundary to Robin</span>
</pre>


<p>Now, we have a domain with fully specified transfer coefficients and defined boundary. Next and final step is to find the matrix of coefficients for the conduction term and the boundary conditions, and solve the linear system of discretized linear equations:</p>
<pre class="code literal-block"><span></span><span class="n">M_cond</span> <span class="p">=</span> <span class="n">diffusionTerm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k_face</span><span class="p">);</span> <span class="c">% matrix of coefficients for the heat diffusion</span>
<span class="p">[</span><span class="n">M_bc</span><span class="p">,</span> <span class="n">RHS_bc</span><span class="p">]</span> <span class="p">=</span> <span class="n">boundaryCondition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">BC</span><span class="p">);</span> <span class="c">% matrix of coefficients and RHS vector for the boundary conditions</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">solvePDE</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">M_cond</span><span class="o">+</span><span class="n">M_bc</span><span class="p">,</span> <span class="n">RHS_bc</span><span class="p">);</span> <span class="c">% solve the linear system of discretized PDE</span>
<span class="n">visualizeCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span> <span class="c">% visualize the results</span>
</pre>


<h3>Little fun</h3>
<p>Please find the source code for this tutorial <a href="https://github.com/simulkade/FVTool/blob/master/Examples/Tutorial/heatconductionfin.m">here</a>. To have some numerical fun, try to change the problem from 2D to 3D by activating the appropriate line in the Matlab source code. You can also increase the heat transfer coefficient and see its effect on the temperature profile. In the next post, I will explain how to convert this example to a unsteady-state simulation.<br>
This is a snapshot of the 3D result:</p>
<p><img alt="3d conduction in a fin" src="heattransfer3dfin.png"></p>
</div>
    </div>
    </article><article class="post h-entry post-text"><header><h1 class="post-title p-name"><a href="posts/2014-05-20-a-simple-finite-volume-toolbox-for-matlab.html" class="u-url">A simple finite volume toolbox for Matlab</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Ali A. Eftekhari</span></p>
            <p class="dateline"><a href="posts/2014-05-20-a-simple-finite-volume-toolbox-for-matlab.html" rel="bookmark"><time class="post-date published dt-published" datetime="2014-05-20T22:35:13+01:00" title="2014-05-20 22:35">2014-05-20 22:35</time></a></p>
                <p class="commentline">
        
    <a href="posts/2014-05-20-a-simple-finite-volume-toolbox-for-matlab.html#disqus_thread" data-disqus-identifier="cache/posts/2014-05-20-a-simple-finite-volume-toolbox-for-matlab.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<h2>An introduction to a Matlab FVM (toy) toolbox</h2>
<p>For some reasons, I had to solve a few PDE's including single/multi phase flow in porous media, heat transfer in saturated porous media, multi-component mass transfer, and so on. My job never included the development of numerical method. In fact, I was supposed to come up with simple and useful models for the physical system that I was/am studying. Solving those models could be done in PDE solver of my choice. At the end of the day, I chose to write my own codes in Matlab.</p>
<h3>Why [in general]?</h3>
<p>Let me count my reasons here. In case you don't like to listen to me bragging about it, you can skip to the middle of this post.</p>
<h4>Black-boxes</h4>
<p>These numerical solvers, in particular <a href="http://www.comsol.com">COMSOL</a> always was like a black-box to me. I could not understand its error messages, which was frustrating, and even when it generated nice results (which most of the times happens), I was really unable to have a physical feeling for it. I will talk about the physical feeling later, and don't expect a post about love-making.</p>
<h4>Boundary conditions</h4>
<p>For some reason, choosing and handling boundary conditions is not explained in books, or papers, or lectures. The same situation applies to the documentation of PDE solvers. Id it really that difficult for you guys to bring us a general Robin boundary condition?</p>
<h4>Geometry</h4>
<p>Honestly, one of the most attractive features of PDE solvers is the graphical pre-processor (with all sort of different mesh generation techniques) and CAD modules. For me, with the simple rectangular or cylindrical geometries of my experimental set-up, there was no need of a fancy pre-processor.</p>
<h4>Learning/Teaching</h4>
<p>I'll be doing a lot of teaching soon, so I needed to learn numerical methods. What's better than learning by doing? Now, I can share my experiences and my coode with my students.</p>
<h3>Why [in particular]?</h3>
<p>I needed a mass conservative scheme (e.g., <a href="http://en.wikipedia.org/wiki/Finite_volume_method">finite volume method</a>), which is implemented in an understandable language (yes, I know. C++ is quite beautiful and elegant and understandable even for a kid with the right genes, but I prefer Matlab), with some flexibility for specifying boundary conditions and changing the physics. I actually found a code. It's called <a href="http://www.ctcms.nist.gov/fipy/">FiPy</a>. But I was already comfortable with Matlab and, don't tell anyone, I couldn't understand <a href="https://www.python.org/">Python</a> and <a href="http://www.numpy.org/">NumPy</a>. So having FiPy's syntax in mind I decided to write my own code in Matlab. I think it is in good enough shape to be shared with other FVM/Matlab users.</p>
<h3>Really! Why?</h3>
<p>For most of our important PDE's in chemical and petroleum engineering (did I mention that I'm a chemical/petroleum engineer?) we have analytical solutions. Also, most of the experiments that we do in the lab can be modeled with a one dimensional PDE. However, so many curious things happen when we go to a two- or three-dimensional domain. I wanted to have something, like FiPy, to make me able to solve a 1D equation, verify it by comparing it to my analytical solution or experimental data, and switch it to 2D and 3D domains without too many modifications. I have it now.</p>
<h3>What do we solve?</h3>
<p>We solve this general form of transient convection-diffusion equation:</p>
<p>$$ \alpha\frac{\partial\phi}{\partial t}+\nabla.\left(\mathbf{u}\phi\right)+\nabla.\left(-D\nabla\phi\right)+\beta\phi=\gamma$$ </p>
<p>with the following general (Robin) boundary condition:</p>
<p>$$a\nabla\phi.\mathbf{e}+b\phi=c.$$</p>
<p>All of the coefficients can be defined explicitly for each control volume or on the surface of a control volume.</p>
<h3>Where to find/How to use 'the code'?</h3>
<p>You can download the code from this github repository (click on the <code>download zip</code> button): <a href="https://github.com/simulkade/FVTool">FVTool</a>
Or alternatively, if you are on linux (and hopefully you are), use the command</p>
<pre class="code literal-block"><span></span>git clone https://github.com/simulkade/FVTool
</pre>


<h4>How to start</h4>
<p>Start <a href="http://www.matlab.com">Matlab</a> (or <a href="http://www.gnu.org/software/octave/">Octave</a>), go to the <code>FVTool</code> folder, and type </p>
<pre class="code literal-block"><span></span><span class="n">FVToolStartUp</span> 
</pre>


<p>You must see a few messages and finally you should see <code>FiniteVolumeToolbox has started successfully.</code> in Matlab command prompt.
With the following command, you can see a short document that introduces you to the code:</p>
<pre class="code literal-block"><span></span><span class="n">showdemo</span> <span class="n">FVTdemo</span>
</pre>


<p>If you want to jump into it, you can run the following script to solve a diffusion equation with Dirichlet boundary conditions:</p>
<p><strong>Important Update</strong>: this code does not work with the new version of FVTool. Download the old version <a href="https://github.com/simulkade/FVTool/archive/v0.11.zip">here</a>.</p>
<pre class="code literal-block"><span></span><span class="n">clc</span><span class="p">;</span> <span class="n">clear</span><span class="p">;</span>
<span class="n">L</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span>  <span class="c">% domain length</span>
<span class="n">Nx</span> <span class="p">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c">% number of cells</span>
<span class="n">m</span> <span class="p">=</span> <span class="n">createMesh3D</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nx</span><span class="p">,</span><span class="n">Nx</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">BC</span> <span class="p">=</span> <span class="n">createBC</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="c">% all Neumann boundary condition structure</span>
<span class="n">BC</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">a</span><span class="p">(:)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="c">% Dirichlet for the left boundary</span>
<span class="n">BC</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">a</span><span class="p">(:)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">b</span><span class="p">(:)=</span><span class="mi">1</span><span class="p">;</span> <span class="n">BC</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">c</span><span class="p">(:)=</span><span class="mi">0</span><span class="p">;</span> <span class="c">% right boundary</span>
<span class="n">D_val</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c">% value of the diffusion coefficient</span>
<span class="n">D</span> <span class="p">=</span> <span class="n">createCellVariable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D_val</span><span class="p">);</span> <span class="c">% assign the diffusion coefficient to the cells</span>
<span class="n">D_face</span> <span class="p">=</span> <span class="n">harmonicMean</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D</span><span class="p">);</span> <span class="c">% calculate harmonic average of the diffusion coef on the cell faces</span>
<span class="n">Mdiff</span> <span class="p">=</span> <span class="n">diffusionTerm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">D_face</span><span class="p">);</span> <span class="c">% matrix of coefficients for the diffusion term</span>
<span class="p">[</span><span class="n">Mbc</span><span class="p">,</span> <span class="n">RHSbc</span><span class="p">]</span> <span class="p">=</span> <span class="n">boundaryCondition</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">BC</span><span class="p">);</span> <span class="c">% matix of coefficients and RHS vector for the BC</span>
<span class="n">M</span> <span class="p">=</span> <span class="n">Mdiff</span> <span class="o">+</span> <span class="n">Mbc</span><span class="p">;</span> <span class="c">% matrix of cefficients for the PDE</span>
<span class="n">c</span> <span class="p">=</span> <span class="n">solvePDE</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">M</span><span class="p">,</span> <span class="n">RHSbc</span><span class="p">);</span> <span class="c">% send M and RHS to the solver</span>
<span class="n">visualizeCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c">% visualize the results</span>
</pre>


<p>You can find more examples <a href="https://github.com/simulkade/FVTool/tree/master/Examples/Tutorial">here</a>.</p>
</div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index-2.html" rel="prev">Newer posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="fvtool";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'center' to center equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><footer id="footer"><p>Contents © 2018         <a href="mailto:a.a.eftekhari@outlook.com">Ali A. Eftekhari</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51207335-2', 'auto');
  ga('send', 'pageview');

</script><script src="assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
